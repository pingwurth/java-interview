# 面试题-JVM

#### Java 是如何实现的平台无关？

Java 之所以可以做到跨平台，是因为 Java 虚拟机充当了桥梁。我们写的 java 代码会被编译成 `.class` 文件，这是平台无关的，`.class` 由 jvm 执行，jvm 是平台相关的，由它将 `.class` 翻译成操作系统可执行的二进制的机器码。

#### Java 是编译型还是解释型？

java 既是解释型又是编译型。

一般情况下，字节码是解释执行的，当 JVM 发现某个方法或代码块运行特别频繁的时候，就会人为这是“热点代码”，然后会通过 JIT 即时编译器把热点代码直接翻译成机器码，这些机器码就可以直接被执行了。

#### 简单介绍一下 JIT 优化技术

解释器的执行方式是一边翻译，一边执行，因此执行效率很低。为了解决这样的低效问题，HotSpot 引入了 JIT 技术（Just-In-Time）。

有了 JIT 技术之后，JVM 还是通过解释器进行解释执行。但是，当 JVM 发现某个方法或代码块运行时执行的特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后 JIT 会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。

#### 对 JDK 进程执行 kill -9 有什么影响？

`kill -9` 命令会立刻关闭 Jvm 进程。但是 `kill -9` 的语意是强制关闭，会导致在 Jvm 中执行的服务立刻关闭，来不及收尾。如导致 RPC 服务没有从注册中心取消注册导致服务不可用，如导致事务执行一半直接终止等等。

#### JVM 的运行时内存区域是怎样的？

> JVM 的运行时内存区域主要由 Java 堆、虚拟机栈、本地方法栈、方法区和程序计数器以及运行时常量池组成。
>
> 其中堆、方法区以及运行时常量池是线程之间共享的区域，而栈（本地方法栈+虚拟机栈）、程序计数器都是线程独享的。

**程序计数器**：一个只读的存储器，用于记录 Java 虚拟机正在执行的字节码指令的地址。它是线程私有的，为每个线程维护一个独立的程序计数器，用于指示下一条将要被执行的字节码指令的位置。它保证线程执行一个字节码指令以后，才会去执行下一个字节码指令。

**Java 虚拟机栈**：一种线程私有的存储器，用于存储 Java 中的局部变量。根据Java虚拟机规范，每次方法调用都会创建一个栈帧，该栈帧用于存储局部变量，操作数栈，动态链接，方法出口等信息。当方法执行完毕之后，这个栈帧就会被弹出，变量作用域就会结束，数据就会从栈中消失。

**本地方法栈**：本地方法栈是一种特殊的栈，它与 Java 虚拟机栈有着相同的功能，但是它支持本地代码（ Native Code ）的执行。本地方法栈中存放本地方法（ Native Method ）的参数和局部变量，以及其他一些附加信息。这些本地方法一般是用 C 等本地语言实现的，虚拟机在执行这些方法时就会通过本地方法栈来调用这些本地方法。

**Java 堆**：是存储对象实例的运行时内存区域。它是虚拟机运行时的内存总体的最大的一块，也一直占据着虚拟机内存总量的一大部分。Java 堆由 Java 虚拟机管理，用于存放对象实例，是几乎所有的对象实例都要在上面分配内存。此外，Java 堆还用于垃圾回收，虚拟机发现没有被引用的对象时，就会对堆中对象进行垃圾回收，以释放内存空间。

**方法区**：用于存储已被加载的类信息、常量、静态变量、即时编译后的代码等数据的内存区域。每加载一个类，方法区就会分配一定的内存空间，用于存储该类的相关信息，这部分空间随着需要而动态变化。方法区的具体实现形式可以有多种，比如堆、永久代、元空间等。

**运行时常量池**：是方法区的一部分。用于存储编译阶段生成的信息，主要有字面量和符号引用常量两类。其中符号引用常量包括了类的全限定名称、字段的名称和描述符、方法的名称和描述符。

#### Java 中的对象一定在堆上分配内存吗？

不一定，在 HotSpot 虚拟机中，存在 JIT 优化的机制，JIT 优化中可能会进行逃逸分析，当经过逃逸分析发现某一个局部对象没有逃逸到线程和方法外的话，那么这个对象就可能不会在堆上分配内存，而是进行栈上分配。

#### Java 的堆是如何分代的？为什么分代？

Java 的堆内存分代是指将不同生命周期的堆内存对象存储在不同的堆内存区域中，这里的不同的堆内存区域被定义为“代”。这样做**有助于提升垃圾回收的效率**，因为这样的话就可以为不同的"代"设置不同的回收策略。

一般来说，Java 中的大部分对象都是朝生夕死的，同时也有一部分对象会持久存在。因为如果把这两部分对象放到一起分析和回收，这样效率实在是太低了。通过将不同时期的对象存储在不同的内存池中，就可以节省宝贵的时间和空间，从而改善系统的性能。

**Java 的堆由新生代（Young Generation）和老年代（Old Generation）组成。新生代存放新分配的对象，老年代存放长期存在的对象。**

**新生代（Young）由年轻区（Eden）、Survivor 区组成（From Survivor、To Survivor）**。默认情况下，新生代的 Eden 区和 Survivor 区的空间大小比例是 `8:2`，可以通过 `-XX:SurvivorRatio` 参数调整。

#### 程序计数器为什么是私有的？

程序计数器是记录正在执行的字节码指令的地址，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器。

#### 虚拟机栈和本地方法栈为什么是私有的？

栈是存储方法执行过程中的数据，如果不是线程私有的，那方法就不能同时被多个线程调用执行了。

#### 堆和方法区的区别？

堆存放的是对象、数组和字符串常量池。

方法去存放的是类信息和运行时常量池。

#### 新生代如果只有一个 Eden + 一个 Survivor 可以吗?

这样就不能适用标记复制算法了，使用标记清除就会存在碎片问题，使用标记整理又存在效率问题。

如果还要使用标记复制算法，总要保持一个空着，因为两个区域都要用来分配对象，那空间比例就是 1:1，永远有一半空着，利用率低。

#### YoungGC 和 FullGC 的触发条件是什么？

YoungGC 的触发条件比较简单，那就是当年轻代中的 eden 区分配满的时候就会触发。

FullGC 的触发条件比较复杂也比较多，主要以下几种：

- 老年代空间不足

- 创建一个大对象，超过指定阈值会直接保存在老年代当中，如果老年代空间也不足，会触发 FullGC。

- YoungGC 之后，发现要移到老年代的对象，老年代存不下的时候，会触发一次 FullGC

- 空间分配担保失败

  - 当准备要触发一次 YoungGC 时，会进行空间分配担保，在担保过程中，发现虚拟机会检查老年代最大可用的连续空间小于新生代所有对象的总空间，但是`HandlePromotionFailure=false`，那么就会触发一次 FullGC（HandlePromotionFailure 这个配置，在JDK 7中并不在支持了，这一步骤在该版本已取消）
  - 当准备要触发一次 YoungGC 时，会进行空间分配担保，在担保过程中，发现虚拟机会检查老年代最大可用的连续空间小于新生代所有对象的总空间，但是HandlePromotionFailure=true，继续检查发现老年代最大可用连续空间小于历次晋升到老年代的对象的平均大小时，会触发一次FullGC

- 方法区空间不足
  
- 代码中执行 `System.gc()`

  - 代码中执行 `System.gc()` 的时候，会触发 FullGC，但是并不保证一定会立即触发。

#### 什么是 Stop The World

Java 中 Stop-The-World 机制简称 STW，是在执行垃圾收集算法时，Java 应用程序的其他所有线程都被挂起。这是 Java 中一种全局暂停现象，全局停顿，所有 Java 代码停止，native 代码可以执行，但不能与 JVM 交互。

不管选择哪种 GC 算法，stop-the-world 都是不能彻底避免的，只能尽量降低 STW 的时长。

**为什么需要 STW 呢？**

首先，如果不暂停用户线程，就意味着期间会不断有垃圾产生，永远也清理不干净。

其次，用户线程的运行必然会导致对象的引用关系发生改变，这就会导致两种情况：漏标和多标。

- **多标：**其实就是这个对象原本应该被回收掉的垃圾对象，但是被错误的标记成了存活对象。从而导致这个对象没有被 GC 回收掉。 这种情况还好一点，无非就是产生了一些浮动垃圾，下次 GC 再清理就好了。

- **漏标：**一个对象本来应该是存活对象，但是没有被正确的标记上，导致被错误的垃圾回收掉了。

#### JVM有哪些垃圾回收算法？
