# 面试题-JVM

#### Java 是如何实现的平台无关？

Java 之所以可以做到跨平台，是因为 Java 虚拟机充当了桥梁。我们写的 java 代码会被编译成 `.class` 文件，这是平台无关的，`.class` 由 jvm 执行，jvm 是平台相关的，由它将 `.class` 翻译成操作系统可执行的二进制的机器码。

#### Java 是编译型还是解释型？

java 既是解释型又是编译型。

一般情况下，字节码是解释执行的，当 JVM 发现某个方法或代码块运行特别频繁的时候，就会人为这是“热点代码”，然后会通过 JIT 即时编译器把热点代码直接翻译成机器码，这些机器码就可以直接被执行了。

#### 简单介绍一下 JIT 优化技术

解释器的执行方式是一边翻译，一边执行，因此执行效率很低。为了解决这样的低效问题，HotSpot 引入了 JIT 技术（Just-In-Time）。

有了 JIT 技术之后，JVM 还是通过解释器进行解释执行。但是，当 JVM 发现某个方法或代码块运行时执行的特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后 JIT 会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。

#### 对 JDK 进程执行 kill -9 有什么影响？

`kill -9` 命令会立刻关闭 Jvm 进程。但是 `kill -9` 的语意是强制关闭，会导致在 Jvm 中执行的服务立刻关闭，来不及收尾。如导致 RPC 服务没有从注册中心取消注册导致服务不可用，如导致事务执行一半直接终止等等。

#### JVM 的运行时内存区域是怎样的？

> JVM 的运行时内存区域主要由 Java 堆、虚拟机栈、本地方法栈、方法区和程序计数器以及运行时常量池组成。
>
> 其中堆、方法区以及运行时常量池是线程之间共享的区域，而栈（本地方法栈+虚拟机栈）、程序计数器都是线程独享的。

**程序计数器**：一个只读的存储器，用于记录 Java 虚拟机正在执行的字节码指令的地址。它是线程私有的，为每个线程维护一个独立的程序计数器，用于指示下一条将要被执行的字节码指令的位置。它保证线程执行一个字节码指令以后，才会去执行下一个字节码指令。

**Java 虚拟机栈**：一种线程私有的存储器，用于存储 Java 中的局部变量。根据Java虚拟机规范，每次方法调用都会创建一个栈帧，该栈帧用于存储局部变量，操作数栈，动态链接，方法出口等信息。当方法执行完毕之后，这个栈帧就会被弹出，变量作用域就会结束，数据就会从栈中消失。

**本地方法栈**：本地方法栈是一种特殊的栈，它与 Java 虚拟机栈有着相同的功能，但是它支持本地代码（ Native Code ）的执行。本地方法栈中存放本地方法（ Native Method ）的参数和局部变量，以及其他一些附加信息。这些本地方法一般是用 C 等本地语言实现的，虚拟机在执行这些方法时就会通过本地方法栈来调用这些本地方法。

**Java 堆**：是存储对象实例的运行时内存区域。它是虚拟机运行时的内存总体的最大的一块，也一直占据着虚拟机内存总量的一大部分。Java 堆由 Java 虚拟机管理，用于存放对象实例，是几乎所有的对象实例都要在上面分配内存。此外，Java 堆还用于垃圾回收，虚拟机发现没有被引用的对象时，就会对堆中对象进行垃圾回收，以释放内存空间。

**方法区**：用于存储已被加载的类信息、常量、静态变量、即时编译后的代码等数据的内存区域。每加载一个类，方法区就会分配一定的内存空间，用于存储该类的相关信息，这部分空间随着需要而动态变化。方法区的具体实现形式可以有多种，比如堆、永久代、元空间等。

**运行时常量池**：是方法区的一部分。用于存储编译阶段生成的信息，主要有字面量和符号引用常量两类。其中符号引用常量包括了类的全限定名称、字段的名称和描述符、方法的名称和描述符。

#### Java 中的对象一定在堆上分配内存吗？

不一定，在 HotSpot 虚拟机中，存在 JIT 优化的机制，JIT 优化中可能会进行逃逸分析，当经过逃逸分析发现某一个局部对象没有逃逸到线程和方法外的话，那么这个对象就可能不会在堆上分配内存，而是进行栈上分配。

#### Java 的堆是如何分代的？为什么分代？

Java 的堆内存分代是指将不同生命周期的堆内存对象存储在不同的堆内存区域中，这里的不同的堆内存区域被定义为“代”。这样做**有助于提升垃圾回收的效率**，因为这样的话就可以为不同的"代"设置不同的回收策略。

一般来说，Java 中的大部分对象都是朝生夕死的，同时也有一部分对象会持久存在。因为如果把这两部分对象放到一起分析和回收，这样效率实在是太低了。通过将不同时期的对象存储在不同的内存池中，就可以节省宝贵的时间和空间，从而改善系统的性能。

**Java 的堆由新生代（Young Generation）和老年代（Old Generation）组成。新生代存放新分配的对象，老年代存放长期存在的对象。**

**新生代（Young）由年轻区（Eden）、Survivor 区组成（From Survivor、To Survivor）**。默认情况下，新生代的 Eden 区和 Survivor 区的空间大小比例是 `8:2`，可以通过 `-XX:SurvivorRatio` 参数调整。

#### 程序计数器为什么是私有的？

程序计数器是记录正在执行的字节码指令的地址，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器。

#### 虚拟机栈和本地方法栈为什么是私有的？

栈是存储方法执行过程中的数据，如果不是线程私有的，那方法就不能同时被多个线程调用执行了。

#### 堆和方法区的区别？

堆存放的是对象、数组和字符串常量池。

方法去存放的是类信息和运行时常量池。

#### 新生代如果只有一个 Eden + 一个 Survivor 可以吗?

这样就不能适用标记复制算法了，使用标记清除就会存在碎片问题，使用标记整理又存在效率问题。

如果还要使用标记复制算法，总要保持一个空着，因为两个区域都要用来分配对象，那空间比例就是 1:1，永远有一半空着，利用率低。

#### YoungGC 和 FullGC 的触发条件是什么？

YoungGC 的触发条件比较简单，那就是当年轻代中的 eden 区分配满的时候就会触发。

FullGC 的触发条件比较复杂也比较多，主要以下几种：

- 老年代空间不足

- 创建一个大对象，超过指定阈值会直接保存在老年代当中，如果老年代空间也不足，会触发 FullGC。

- YoungGC 之后，发现要移到老年代的对象，老年代存不下的时候，会触发一次 FullGC

- 空间分配担保失败

  - 当准备要触发一次 YoungGC 时，会进行空间分配担保，在担保过程中，发现虚拟机会检查老年代最大可用的连续空间小于新生代所有对象的总空间，但是`HandlePromotionFailure=false`，那么就会触发一次 FullGC（HandlePromotionFailure 这个配置，在JDK 7中并不在支持了，这一步骤在该版本已取消）
  - 当准备要触发一次 YoungGC 时，会进行空间分配担保，在担保过程中，发现虚拟机会检查老年代最大可用的连续空间小于新生代所有对象的总空间，但是HandlePromotionFailure=true，继续检查发现老年代最大可用连续空间小于历次晋升到老年代的对象的平均大小时，会触发一次FullGC

- 方法区空间不足
  
- 代码中执行 `System.gc()`

  - 代码中执行 `System.gc()` 的时候，会触发 FullGC，但是并不保证一定会立即触发。

#### 什么是 Stop The World

Java 中 Stop-The-World 机制简称 STW，是在执行垃圾收集算法时，Java 应用程序的其他所有线程都被挂起。这是 Java 中一种全局暂停现象，全局停顿，所有 Java 代码停止，native 代码可以执行，但不能与 JVM 交互。

不管选择哪种 GC 算法，stop-the-world 都是不能彻底避免的，只能尽量降低 STW 的时长。

**为什么需要 STW 呢？**

首先，如果不暂停用户线程，就意味着期间会不断有垃圾产生，永远也清理不干净。

其次，用户线程的运行必然会导致对象的引用关系发生改变，这就会导致两种情况：漏标和多标。

- **多标：**其实就是这个对象原本应该被回收掉的垃圾对象，但是被错误的标记成了存活对象。从而导致这个对象没有被 GC 回收掉。 这种情况还好一点，无非就是产生了一些浮动垃圾，下次 GC 再清理就好了。

- **漏标：**一个对象本来应该是存活对象，但是没有被正确的标记上，导致被错误的垃圾回收掉了。

#### JVM有哪些垃圾回收算法？

**标记-清除：**会产生内存碎片，但速度快，因为不需要移动和复制。

**标记-复制：**内存空间连续，不会产生内存碎片，但是需要保持一半空闲内存，有点浪费，而且复制有性能消耗。

**标记-整理：**不会产生内存碎片，也不会浪费内存空间，但是非常耗时（性能低）。

#### JVM 如何判断对象是否存活？

JVM 有两种算法来判断对象是否存活，分别是**引用计数法**和**可达性分析算法**。

- **引用计数法：**给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。
  - 循环引用会导致对象无法被回收，最终会导致内存泄漏及内存溢出

- **可达性分析算法：** 这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

**但是，并不是说当进行完可达性分析算法后，即可证明某对象可以被GC。对象是否存活，需要两次标记：**

1. 第一次标记通过可达性分析算法。如果没有 GC Roots 相连接的引用链，那么将第一次标记
2. 如果对象的 `finalize()` 方法被覆盖并且没有执行过，则放在 F-Queue 队列中等待执行(不一定会执行)，如果一段时间后该队列的 `finalize()` 方法被执行且和 GC Roots 关联，则移出“即将回收”集合。如果仍然没有关联，则进行第二次标记，才会对该对象进行回收

不过现在都不提倡覆盖 finalize 方法，它的本意是像 Cpp 一样在对象销毁前执行，但是它影响了 JAVA 的安全和 GC 的性能，所以第二种判断会越来越少。

#### 哪些对象可以作为 GC roots？

- **局部变量**，就是虚拟机栈的栈帧中本地变量表引用的对象
- **native 方法中的局部变量**，本地方法栈引用的对象
- **static 类静态成员**，方法区中类静态属性引用的对象
- **方法区中常量引用的对象**
- **synchronized 同步锁持有的对象**
- **JVM 内部引用**：基本数据类型对应的 Class 对象、常驻异常对象（NullPointException, OutOfMemoryError)、系统类加载器。
- **反应 JVM 内部情况的 JMXBean、JVMT1 中注册的回调、本地代码缓存等**
- 不同垃圾收集器还可以有其他对象“临时性”地加入

#### 什么是三色标记算法？

三色标记算法是一种 JVM 中垃圾标记的算法，他可以减少 JVM 在 GC 过程中的 STW 时长，他是 CMS、G1 等垃圾收集器中主要使用的标记算法。

在出现三色标记算法之前，JVM 中垃圾对象的标记主要采用可达性分析算法及引用计数法。但是这两种算法存在以下问题：

1. 循环引用问题，如果两个对象互相引用，就形成了一个环形结构，如果采用引用计数法的话，那么这两个对象将永远无法被回收。
2. STW 时间长，可达性分析的整个过程都需要 STW，以避免对象的状态发生改变，这就导致 GC 停顿时长很长，大大影响应用的整体性能。

**为了解决上面这些问题，就引入了三色标记法。**

> 三色标记法将对象分为三种状态：白色、灰色和黑色。

- 白色：该对象没有被标记过。
- 灰色：该对象已经被标记过了，但该对象的引用对象还没标记完。
- 黑色：该对象已经被标记过了，并且他的全部引用对象也都标记完了。

三色标记法的标记过程可以分为**三个阶段：**初始标记（Initial Marking）、并发标记（Concurrent Marking）和重新标记（Remark）。

- **初始标记：**遍历所有的根对象，将根对象和直接引用的对象标记为灰色。在这个阶段中，垃圾回收器只会扫描被直接或者间接引用的对象，而不会扫描整个堆。因此，初始标记阶段的时间比较短。（Stop The World）
- **并发标记：**在这个过程中，垃圾回收器会从灰色对象开始遍历整个对象图，将被引用的对象标记为灰色，并将已经遍历过的对象标记为黑色。并发标记过程中，应用程序线程可能会修改对象图，因此垃圾回收器需要使用写屏障（Write Barrier）技术来保证并发标记的正确性。（不需要STW）
- **重新标记：**重新标记的主要作用是标记在并发标记阶段中被修改的对象以及未被遍历到的对象。这个过程中，垃圾回收器会从灰色对象重新开始遍历对象图，将被引用的对象标记为灰色，并将已经遍历过的对象标记为黑色。（Stop The World）

在重新标记阶段结束之后，垃圾回收器会执行清除操作，将未被标记为可达对象的对象进行回收，从而释放内存空间。这个过程中，垃圾回收器会将所有未被标记的对象标记为白色（White）。

以上三个标记阶段中，初始标记和重新标记是需要 STW 的，而并发标记是不需要 STW 的。其中最耗时的其实就是并发标记的这个阶段，因为这个阶段需要遍历整个对象树，而三色标记把这个阶段做到了和应用线程并发执行，大大降低了 GC 的停顿时长。

#### Java 中的四种引用有什么区别？

**强引用：**强引用是 Java 的默认引用形式，使用时不需要显示定义。如果一个对象具有强引用，那垃圾回收器绝不会回收它（可达时）。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

**弱引用：** 如果一个对象只具有弱引用，无论内存充足与否，Java GC 后对象如果只有弱引用将会被自动回收。

```java
WeakReference<String[]> weakBean = new WeakReference<String[]>(new String[]{"a", "b", "c"});
```

**软引用：** 软引用不会保证对象一定不会被回收，只能最大可能保证。软引用和弱引用的特性基本一致， 主要的区别在于软引用在内存不足时才会被回收。如果一个对象只具有软引用，Java GC 在内存充足的时候不会回收它，内存不足时才会被回收。

```java
SoftReference<String[]> softBean = new SoftReference<String[]>(new String[]{"a", "b", "c"});
```

**虚引用：**`java.lang.ref.PhantomReference` 类中只有一个方法 `get()`，而且几乎没有实现，只是返回 null。如果一个对象仅有虚引用，那么它就像没有任何引用一样，在任何时候都可能被 gc 回收。虚引用主要用来跟踪对象被垃圾回收的活动。

#### 新生代和老年代的 GC 算法

对于新生代来说，一般来说GC的次数是要比老年代高很多的，所以需要一个效率更高的算法，而且最好不要有碎片，因为很多对象都是需要先在新生代分配空间的，如果碎片太多的话，那么就会导致很多对象无法正常分配了。

所以，新生代选择了标记复制算法进行垃圾回收。

对于老年代来说，通常会采用标记整理算法，虽然效率低了一点，但是可以减少空间的浪费并且不会有空间碎片等问题。在有些回收器上面，如 CMS，为了降低 STW 的时长，也会采用标记清除算法。

#### 新生代和老年代的垃圾回收器有何区别？

常见的垃圾回收器如下：

- 串行垃圾回收器（Serial Garbage Collector） 如：Serial GC， Serial Old
- 并行垃圾回收器（Parallel Garbage Collector） 如：Parallel Scavenge，Parallel Old，ParNew
- 并发标记扫描垃圾回收器（CMS Garbage Collector） 
- G1垃圾回收器（G1 Garbage Collector，JDK 7中推出，JDK 9中设置为默认） 
- ZGC垃圾回收器（The Z Garbage Collector，JDK 11 推出）

**新生代收集器有 Serial、ParNew、Parallel Scavenge；**
**老年代收集器有 Serial Old、Parallel Old、CMS；**
**整堆收集器有 G1、ZGC。**

#### G1 和 CMS 有什么区别？

G1 会把 Java 的堆分为多个大小相等的 Region（每个 Region 的大小为 `1M~32M` ），他在年轻代回收的时候采用标记-复制算法，而在老年代回收的时候，采用的是标记-整理算法，这两种算法都可以避免内存碎片的产生。

G1 在回收的过程中，标记和清理的过程是并行的，可以充分利用多个 CPU 来缩短 STW 的时长，在复制的过程中是并发的，可以让复制线程和用户线程并发执行，不需要 STW。并且 G1 还可以在运行时动态的做区域内存大小的调整。

#### 为什么 G1 从 JDK 9 之后成为默认的垃圾回收器？

