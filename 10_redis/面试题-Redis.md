# 面试题-Redis

#### Redis 是 AP 的还是 CP 的？

Redis是一个开源的内存数据库，那么他到底是 AP 的还是 CP 的呢？

有人说：单机的 Redis 是 CP 的，而集群的 Redis 是 AP 的？

但是我不这么认为，我觉得 Redis 就是 AP 的，虽然在单机 Redis 中，因为只有一个实例，他的一致性是有保障的，而一旦这个节点挂了，那么就没有可用性可言了。这么看上去好像是个 CP 系统。

但是，CAP 是分布式场景中的理论，如果单机 Redis，那就没啥分布式可言了。P 都没有了，还谈什么 AP、CP 呢？

> 那么，我们来说说，为啥Redis是AP的呢？

Redis 的设计目标是高性能、高可扩展性和高可用性，Redis的一致性模型是最终一致性，即在某个时间点读取的数据可能并不是最新的，但最终会达到一致的状态。

Redis 没办法保证强一致性的主要原因是，因为它的分布式设计中采用的是异步复制，这导致在节点之间存在数据同步延迟和不一致的可能性。

也就是说，当某个节点上的数据发生改变时，Redis 会将这个修改操作发送给其他节点进行同步，但由于网络传输的延迟等原因，这些操作不一定会立即被其他节点接收到和执行，这就可能导致节点之间存在数据不一致的情况。

除此之外，Redis的一致性还受到了节点故障的影响。当一个节点宕机时，这个节点上的数据可能无法同步到其他节点，这就可能导致数据在节点之间的不一致。虽然 Redis 通过复制和哨兵等机制可以提高系统的可用性和容错性，但是这些机制并不能完全解决数据一致性问题。

如果用同步复制的方式呢？

会不会就是 CP 了呢？并不会，这一点在 Redis 的官网中自己明确的说了：

> 客户端可以使用 WAIT 命令请求对特定数据进行同步复制。然而，WAIT 仅能确保数据在 Redis 实例中有指定数量的副本中被确认，它并不能将一组 Redis 实例转变为具有强一致性的 CP 系统：在故障转移期间，已确认的写操作仍然可能会丢失，这取决于 Redis 持久化的具体配置。然而，使用 WAIT 后，在发生故障事件时丢失写操作的概率大大降低，只在某些难以触发的故障模式下才会发生。



#### 介绍一下 Redis 的集群模式？

Redis 有三种主要的集群模式，用于在分布式环境中实现高可用性和数据复制。这些集群模式分别是：主从复制（Master-Slave Replication）、哨兵模式（Sentinel）和 Redis Cluster 模式。



**主从模式**



主从复制是 Redis 最简单的集群模式。这个模式主要是为了解决单点故障的问题，所以将数据复制多个副本中，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。

主从模式中，包括一个主节点（Master）和一个或多个从节点（Slave）。主节点负责处理所有写操作和读操作，而从节点则复制主节点的数据，并且只能处理读操作。当主节点发生故障时，可以将一个从节点升级为主节点，实现故障转移（需要手动实现）。

![主从模式-1](./images/主从模式-1.png)

**主从复制的优势在于简单易用，适用于读多写少的场景**。它提供了数据备份功能，并且可以有很好的扩展性，只要增加更多的从节点，就能让整个集群的读的能力不断提升。

但是主从模式最大的缺点，就是不具备故障自动转移的能力，没有办法做容错和恢复。

主节点和从节点的宕机都会导致客户端部分读写请求失败，需要人工介入让节点恢复或者手动切换一台从节点服务器变成主节点服务器才可以。并且在主节点宕机时，如果数据没有及时复制到从节点，也会导致数据不一致。

![主从模式-2](./images/主从模式-2.png)

**哨兵模式**



为了解决主从模式的无法自动容错及恢复的问题，Redis 引入了一种哨兵模式的集群架构。

哨兵模式是在主从复制的基础上加入了哨兵节点。哨兵节点是一种特殊的 Redis 节点，用于监控主节点和从节点的状态。当主节点发生故障时，哨兵节点可以自动进行故障转移，选择一个合适的从节点升级为主节点，并通知其他从节点和应用程序进行更新。

![哨兵模式](./images/哨兵模式.png)

在原来的主从架构中，引入哨兵节点，其作用是监控 Redis 主节点和从节点的状态。每个 Redis 实例都可以作为哨兵节点，通常需要部署多个哨兵节点，以确保故障转移的可靠性。

哨兵节点定期向所有主节点和从节点发送 **PING** 命令，如果在指定的时间内未收到 **PONG** 响应，哨兵节点会将该节点标记为主观下线。如果一个主节点被多数哨兵节点标记为**主观下线**，那么它将被标记为**客观下线**。

当主节点被标记为**客观下线**时，哨兵节点会触发故障转移过程。它会从所有健康的从节点中选举一个新的主节点，并将所有从节点切换到新的主节点，实现自动故障转移。同时，哨兵节点会更新所有客户端的配置，指向新的主节点。

哨兵节点通过发布订阅功能来通知客户端有关主节点状态变化的消息。客户端收到消息后，会更新配置，将新的主节点信息应用于连接池，从而使客户端可以继续与新的主节点进行交互。

这个集群模式的优点就是为整个集群系统了一种故障转移和恢复的能力。



**Cluster 模式**



Redis Cluster 是 Redis 中推荐的分布式集群解决方案。它将数据**自动分片**到多个节点上，每个节点负责一部分数据。 

![Cluster模式](./images/Cluster模式.png)

Redis Cluster 采用主从复制模式来提高可用性。每个分片都有一个主节点和多个从节点。主节点负责处理写操作，而从节点负责复制主节点的数据并处理读请求。

Redis Cluster 能够自动检测节点的故障。当一个节点失去连接或不可达时，Redis Cluster 会尝试将该节点标记为不可用，并从可用的从节点中提升一个新的主节点。

Redis Cluster 是适用于大规模应用的解决方案，它提供了更好的横向扩展和容错能力。它自动管理数据分片和故障转移，减少了运维的负担。

Cluster 模式的特点是数据分片存储在不同的节点上，每个节点都可以单独对外提供读写服务。不存在单点故障的问题。

#### 什么是 Redis 的数据分片？

Redis 的数据分片（sharding）是一种将一个 Redis 数据集分割成多个部分，分别存储在不同的 Redis 节点上的技术。它可以用于将一个单独的 Redis 数据库扩展到多个物理机器上，从而提高Redis集群的性能和可扩展性。

Redis 数据分片的实现方式通常是将数据按照某种规则（例如，key 的 hash 值）分配到不同的节点上。当客户端想要访问某个 key 时，它会先计算出这个 key 应该存储在哪个节点上，然后直接连接到该节点进行操作。因此，对于客户端而言，Redis集群就像是一个大型的、统一的数据库，而不需要关心数据的实际分布情况。

**在 Redis 的 Cluster 集群模式中，使用哈希槽（hash slot）的方式来进行数据分片**，将整个数据集划分为多个槽，每个槽分配给一个节点。客户端访问数据时，先计算出数据对应的槽，然后直接连接到该槽所在的节点进行操作。Redis Cluster 还提供了自动故障转移、数据迁移和扩缩容等功能，能够比较方便地管理一个大规模的 Redis 集群。

![Redis数据分片](./images/Redis数据分片.png)

Redis Cluster 将整个数据集划分为 **16384 个槽**，每个槽都有一个编号（0~16383），集群的每个节点可以负责多个hash槽，客户端访问数据时，先根据key计算出对应的槽编号，然后根据槽编号找到负责该槽的节点，向该节点发送请求。

在 Redis 的每一个节点上，都有这么两个东西，一个是槽（slot），它的的取值范围是：0-16383。还有一个就是 cluster，可以理解为是一个集群管理的插件。当我们的存取的 Key 的时候，Redis 会根据 CRC16 算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。

Redis Cluster 中的数据分片具有以下特点：

1. **提升性能和吞吐量：**通过在多个节点上分散数据，可以并行处理更多的操作，从而提升整体的性能和吞吐量。这在高流量场景下尤其重要，因为单个节点可能无法处理所有请求。
2. **提高可扩展性：**分片使得Redis可以水平扩展。可以通过添加更多节点扩展数据库的容量和处理能力。
3. **更好的资源利用：**分片允许更有效地利用服务器资源。每个节点只处理数据的一部分，这降低了单个节点的内存和计算需求。
4. **避免单点故障：**在没有分片的情况下，如果唯一的Redis服务器发生故障，整个服务可能会停止。在分片的环境中，即使一个节点出现问题，其他节点仍然可以继续运行。
5. **数据冗余和高可用性：**在某些分片策略中，如 Redis 集群，每个分片的数据都可以在集群内的其他节点上进行复制。这意味着即使一个节点失败，数据也不会丢失，从而提高了系统的可用性。

> Redis Cluster 将整个数据集划分为 16384 个槽，为什么是 16384 呢，这个数字有什么特别的呢？

这个问题在Github上有所讨论，Redis的作者也下场做过回复：https://github.com/redis/redis/issues/2576

> The reason is:
>
> 1、Normal heartbeat packets carry the full configuration of a node, that can be replaced in an idempotent way with the old in order to update an old config. This means they contain the slots configuration for a node, in raw form, that uses 2k of space with16k slots, but would use a prohibitive 8k of space using 65k slots.
>
> 2、At the same time it is unlikely that Redis Cluster would scale to more than 1000 mater nodes because of other design tradeoffs.
>
> So 16k was in the right range to ensure enough slots per master with a max of 1000 maters, but a small enough number to propagate the slot configuration as a raw bitmap easily. Note that in small clusters the bitmap would be hard to compress because when N is small the bitmap would have slots/N bits set that is a large percentage of bits set.

16384 这个数字是一个 2 的 14 次方（2^14），尽管 crc16 能得到 2^16 -1=65535 个值，但是并没有选择，主要从消息大小和集群规模等方面考虑的：

1、正常的心跳数据包携带了节点的完整配置，在更新配置的时候，可以以幂等方式进行替换。这意味着它们包含了节点的原始槽配置，对于包含 16384 个槽位的情况，使用 2k 的空间就够了，但如果使用 65535 个槽位，则需要使用 8k 的空间，这就有点浪费了。

2、由于其他设计权衡的原因，Redis Cluster 不太可能扩展到超过 1000 个主节点，这种情况下，用 65535 的话会让每个节点上面的 slot 太多了，会导致节点的负载重并且数据迁移成本也比较高。而 16384 是相对比较好的选择，可以在 1000 个节点下使得 slot 均匀分布，每个分片平均分到的 slot 不至于太小。

除此之外，还有一些原因和优点供大家参考：

1、易于扩展：槽数量是一个固定的常数，这样就可以方便地进行集群的扩展和缩小。如果需要添加或删除节点，只需要将槽重新分配即可。

2、易于计算：哈希算法通常是基于槽编号计算的，**将槽数量设置为2的幂次方，可以使用位运算等简单的算法来计算槽编号，从而提高计算效率**。

3、负载均衡：槽数量的选择可以影响数据的负载均衡。如果槽数量太少，会导致某些节点负载过重；如果槽数量太多，会导致数据迁移的开销过大。**16384 这个数量在实践中被证明是一个比较合适的选择，能够在保证负载均衡的同时，减少数据迁移的开销。**

#### Redis 使用什么协议进行通信？

**Redis 使用自己设计的一种文本协议进行客户端与服务端之间的通信——RESP（REdis Serialization Protocol）**，这种协议简单、高效，易于解析，被广泛使用。

RESP 协议基于 TCP 协议，采用请求/响应模式，每条请求由多个参数组成，以命令名称作为第一个参数。请求和响应都以行结束符（`\r\n`）作为分隔符，具体格式如下：

```bash
*<number of arguments>\r\n
$<length of argument 1>\r\n
<argument data>\r\n
...
$<length of argument N>\r\n
<argument data>\r\n
```

其中，`<number of arguments>` 表示参数个数，`<length of argument>` 表示参数数据的长度，`<argument data>` 表示参数数据。参数可以是字符串、整数、数组等数据类型。

例如，以下是一个 Redis 协议的示例请求和响应：
请求：

```bash
*3\r\n
$3\r\n
SET\r\n
$5\r\n
mykey\r\n
$7\r\n
myvalue\r\n
```

响应：

```bash
+OK\r\n
```

上面的请求表示向 Redis 服务器设置一个名为 "mykey" 的键，值为 "myvalue"。响应返回 "+OK" 表示操作成功。

> "$3\r\n" 表示参数长度为 3，即下一个参数是一个 3 个字符的字符串。它表示要执行的命令是"SET"，即设置键值对。
>
> "$5\r\n" 表示参数长度为 5，即下一个参数是一个 5 个字符的字符串。它表示要设置的键是"mykey"。
>
> "$7\r\n" 表示参数长度为 7，即下一个参数是一个 7 个字符的字符串。它表示要设置的值是"myvalue"。

除了基本的 GET、SET 操作，Redis 还支持事务、Lua 脚本、管道等高级功能，这些功能都是通过 Redis 协议来实现的。

#### Redis 与 Memcached 有什么区别？

Redis 和 Memcached 都是常见的缓存服务器，它们的主要区别包括以下几个方面：

**1、数据结构不同：**Redis 提供了多种数据结构，如字符串、哈希表、列表、集合、有序集合等，而 Memcached 只支持简单的键值对存储。

**2、持久化方式不同：**Redis 支持多种持久化方式，如 RDB 和 AOF，可以将数据持久化到磁盘上；而 Memcached 不支持持久化。

**3、数据分片方式不同：**Redis 使用哈希槽分片，可以实现数据的自动分片和负载均衡；而 Memcached 只能手动分片。

**4、处理数据的方式不同：**Redis 使用单线程处理数据请求，支持事务、Lua 脚本等高级功能；而 Memcached 使用多线程处理数据请求，只支持基本的 GET、SET 操作。

**5、协议不同：**Redis 使用自己的协议，支持多个数据库，可以使用密码进行认证；而 Memcached 使用文本协议，只支持一个默认数据库。

**6、内存管理方式不同：**Redis 的内存管理比 Memcached 更加复杂，支持更多的内存优化策略。

综上所述，Redis 和 Memcached 有着不同的设计理念和应用场景。R**edis 适用于数据结构复杂、需要高级功能和数据持久化的场景；而 Memcached 则适用于简单的键值存储场景**。

#### Redis 为什么这么快？

Redis 之所以如此快，主要有以下几个方面的原因：

**1、基于内存：**Redis 是一种基于内存的数据库，数据存储在内存中，数据的读写速度非常快，因为内存访问速度比硬盘访问速度快得多。

**2、单线程模型：**Redis 使用单线程模型，这意味着它的所有操作都是在一个线程内完成的，不需要进行线程切换和上下文切换。这大大提高了 Redis 的运行效率和响应速度。

**3、多路复用 I/O 模型：**Redis 在单线程的基础上，采用了I/O 多路复用技术，实现了单个线程同时处理多个客户端连接的能力，从而提高了 Redis 的并发性能。

**4、高效的数据结构：**Redis 提供了多种高效的数据结构，如哈希表、有序集合、列表等，这些数据结构都被实现得非常高效，能够在 O(1) 的时间复杂度内完成数据读写操作，这也是 Redis 能够快速处理数据请求的重要因素之一。

**5、多线程的引入：**在 Redis 6.0 中，为了进一步提升 IO 的性能，引入了多线程的机制。采用多线程，使得网络处理的请求并发进行，就可以大大的提升性能。多线程除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势。

![Redis为什么这么快](./images/Redis为什么这么快.png)

#### Redis 支持哪几种数据类型？

Redis 中支持了多种数据类型，其中比较常用的有五种：

1. 字符串（String）
2. 哈希（Hash）
3. 列表（List）
4. 集合（Set）
5. 有序集合（Sorted Set）

另外，Redis 中还支持一些高级的数据类型，如：Streams、Bitmap、Geospatial 以及 HyperLogLog

#### Redis 为什么要自己定义 SDS？

Redis 是一种 KV 的存储结构，他的 key 是字符串类型，值也支持字符串，所以字符串是 redis 中最常见的一个类型了。**Redis 自己本身是通过C语言实现的**，但是他并没有直接使用 C 语言中的字符数组的方式来实现字符串，而是自己实现了一个 SDS（Simple Dynamic Strings），即简单动态字符串，这是为什么呢？

首先，因为字符串在 Redis **中使用实在是太广泛了** ，所以对他的基本要求就有两点，**第一就是要支持任意字符的存储，第二就是各种操作需要高效**。

接着我们看看 C 语言中字符串的实现方式有什么问题呢？很多人可能都忘了，我帮大家回忆一下，C语言中，字符串是通过字符数组实现的，底层呢是开辟了一块连续的空间，依次存放字符串中的每一个字符。为了表示字符串的结束，他会在字符数组的最后一个字符处记录 `\0`，

也就是说，在 C 语言中，当识别到字符数组中的 `\0` 字符的时候，就认为字符串结束了，那么这么做会带来哪些问题呢？

就是**这样实现的字符串中就不能保存任意内容了**，至少 `\0`就不行，因为遇到他的时候就直接截断了，这肯定是接受不了的。

还有就是因为 **C 中的字符串以 `\0` 作为识别字符串结束的方式，所以他的字符串长度判断、字符串追加等操作，都需要从头开始遍历，一直遍历到\0的时候再返回长度或者做追加。这就使得字符串相关的操作效率都很低。**

那么，想要解决上面的两个问题要怎么办呢？那就是**在用字符数组表示字符串的同时，在这个字符串中增加一个表示分配给该字符数组的总长度的 alloc 字段，和一个表示字符串现有长度的 len 字段。这样在获取长度的时候就不依赖\0了，直接返回 len 的值就行了**。

还有呢，就是在做追加操作的时候，只需要判断新追加的部分的 len 加上已有的 len 是否大于 alloc，如果超过就重新再申请新空间，如果没超过，就直接进行追加就行了。

还有很多其他操作，比如复制、比较等都可以使用类似的思想高效的操作。

#### Redis 中的 Zset 是怎么实现的？

ZSet（也称为Sorted Set）是Redis中的一种特殊的数据结构，它内部维护了一个有序的字典，这个字典的元素中既包括了一个成员（member），也包括了一个double类型的分值(score)。这个结构可以帮助用户实现记分类型的排行榜数据，比如游戏分数排行榜，网站流行度排行等。

> Redis 中的 ZSet 在实现中，有多种结构，大类的话有两种，分别是 ziplist(压缩列表) 和 skiplist(跳跃表)，但是这只是以前，在 Redis 5.0 中新增了一个 listpack（紧凑列表）的数据结构，这种数据结构就是为了替代 ziplist 的，而在之后Redis 7.0的发布中，在 Zset 的实现中，已经彻底不在使用 zipList 了。

![Zset](./images/Zset.png)

当 ZSet 的元素数量比较少时，Redis 会采用 ZipList（ListPack）来存储ZSet的数据。ZipList（ListPack）是一种紧凑的列表结构，它通过连续存储元素来节约内存空间。当 ZSet 的元素数量增多时，Redis会自动将ZipList（ListPack）转换为 SkipList，以保持元素的有序性和支持范围查询操作。

在这个过程中，Redis 会遍历 ZipList（ListPack）中的所有元素，按照元素的分数值依次将它们插入到 SkipList 中，这样就可以保持元素的有序性。

**在 Redis 的 ZSET 具体实现中，SkipList 的这种实现，不仅用到了跳表，还会用到 dict（字典）**

![SkipList](./images/SkipList.png)

其中，SkipList 用来实现有序集合，其中每个元素按照其分值大小在跳表中进行排序。跳表的插入、删除和查找操作的时间复杂度都是 O(log n)，可以保证较好的性能。

dict 用来实现元素到分值的映射关系，其中元素作为键，分值作为值。哈希表的插入、删除和查找操作的时间复杂度都是 O(1)，具有非常高的性能。

![zset结构](./images/zset结构.png)

#### ZipList（ListPack）和 SkipList 之间是什么时候进行转换的呢？

在 Redis 中，ZSET 在特定条件下会使用 ziplist 作为其内部表示。这通常发生在有序集合较小的时候，具体条件如下：

1. 元素数量少：集合中的元素数量必须小于某个阈值（zset-max-ziplist-entries）。
2. 元素大小小：集合中的每个元素（包括值和分数）的大小必须小于指定的最大值（zset-max-ziplist-value）。

默认情况下，zset-max-ziplist-entries 是 128，zset-max-ziplist-value 是 64。

**总的来说就是，当元素数量少于 128，每个元素的长度都小于 64 字节的时候，使用 ZipList（ListPack），否则，使用 SkipList！**

#### 跳表的结构

跳表也是一个有序链表。

在链表中，我们想要查找一个数，需要从头结点开始向后依次遍历和匹配，直到查到为止，这个过程是比较耗费时间的，他的时间复杂度是 0(n)。

当我们想要向这个链表中插入一个数的时候，过程和查找类似，先需要从头开始遍历找到合适的为止，然后再插入，他的时间复杂度也是 O(n)。

那么，怎么能提升遍历速度呢，有一个办法，那就是我们对链表进行改造，先对链表中每两个节点建立第一级索引

![跳表](./images/跳表.png)

有了我们创建的这个索引之后，我们查询元素 12，我们先从一级索引 `6 -> 9 -> 17 -> 26` 中查找，发现 12 介于 9 和17之间，然后，转移到下一层进行搜索，即 `9 -> 12 -> 17`，即可找到 12 这个节点了。

可以看到，同样是查找 12，原来的链表需要遍历 5 个元素`(3、6、7、9、12)`，建立了一层索引之后，只需要遍历4个元素即可`（6、9、17、12）`。

像上面这种带多级索引的链表，就是跳表。

#### 什么是 GEO，有什么用？

GEO 就是 Geolocation 的简写形式，代表地理坐标，Redis GEO 主要用于存储地理位置信息的，帮助我们根据经纬度来检索数据。

它主要支持如下命令：

- GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）
- GEODIST：计算指定的两个点之间的距离并返回
- GEOHASH：将指定member的坐标转为hash字符串形式并返回
- GEOPOS：返回指定member的坐标
- GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。
- GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。
- GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。

#### Redis 为什么被设计成是单线程的？



#### 为什么 Redis 设计成单线程也能这么快？

#### 为什么 Redis 6.0 引入了多线程？

#### 为什么 Lua 脚本可以保证原子性？

#### Redis 中的 setnx 命令为什么是原子性的?

#### Redis 5.0 中的 Stream 是什么？

#### Redis 的虚拟内存机制是什么？

#### Redis 的持久化机制是怎样的？

#### Redis 的事务机制是怎样的？

#### Redis 的过期策略是怎么样的？

#### Redis 的内存淘汰策略是怎么样的？

#### 什么是热 Key 问题，如何解决热 key 问题

#### 什么是大 Key 问题，如何解决？

#### 什么是缓存击穿、缓存穿透、缓存雪崩？

#### 什么情况下会出现数据库和缓存不一致的问题？

#### 如何解决 Redis 和数据库的一致性问题？

#### Redis 如何实现延迟消息？

#### Redis 如何实现发布/订阅？

#### 除了做缓存，Redis 还能用来干什么？

#### 对于 Redis 的操作，有哪些推荐的 Best Practices？

#### 如何用 SETNX 实现分布式锁？

#### 什么是 RedLock，他解决了什么问题？

#### 如何用 Redisson 实现分布式锁？

#### 为什么 ZSet 既能支持高效的范围查询，还能以 O(1) 复杂度获取元素权重值？

#### Redisson 的 watch dog 机制是怎么样的？

#### 什么是 Redis 的渐进式 rehash

#### Redis 中 key 过期了一定会立即删除吗?

#### Redis 中有一批 key 瞬间过期，为什么其它 key 的读写效率会降低？

#### 如何基于 Redis 实现滑动窗口限流？

#### 如何基于 Redisson 实现一个延迟队列

#### 介绍下 Redis 集群的脑裂问题？

#### 为什么需要延迟双删，两次删除的原因是什么？

#### Redis 的 Key 和 Value 的设计原则有哪些？

#### Redisson 和 Jedis 有啥区别？如何选择？

#### 什么是 Redis 的 Pipeline，和事务有什么区别？

#### Redis 的事务和 Lua 之间有哪些区别？

#### Redisson 的 lock 和 tryLock 有什么区别？

#### 为什么 Redis 不支持回滚？

#### 如何用 Redis 实现乐观锁？

#### watch dog 一直续期，那客户端挂了怎么办？

#### 如何用 setnx 实现一个可重入锁？

#### Redis 实现分布锁的时候，哪些问题需要考虑？

#### Redis 如何高效安全的遍历所有 key ?

#### watch dog 解锁失败，会不会导致一直续期下去？

#### Redis Cluster 中使用事务和 lua 有什么限制？

#### 如何在 Redis Cluster 中执行 lua 脚本？

#### Redisson 中为什么要废弃 RedLock，该用啥？
