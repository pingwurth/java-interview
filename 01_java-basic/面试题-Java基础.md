# 面试题-Java基础

#### Java 和 C++ 的区别？说说各自的优缺点

Java 是解释型语言，C++ 是编译型语言。

我们写的代码都要翻译成机器码，它是计算机可以直接执行的指令，解释型语言和编译型语言的区别就是翻译的时机不同。

- 解释型语言：
  - 先将源代码编译成一个中间码，比如 Java 的 class 文件，它是一种 JVM 可执行的十六进制字节码；
  - 然后在程序运行的时候，一行一行地解释、翻译成机器码、执行指令，Java 就需要搭配 Java 虚拟机来完成这部分工作。
- 编译型语言：
  - 在程序运行之前，就把源代码直接翻译成机器码；
  - 执行速度快、效率高，但跨平台性差。

Java 的优点就是跨平台性好，缺点是执行速度慢、效率低。

也有人说 Java 是半编译、半解释型语言。先用 Java 编译器（javac）将源代码编译成 Java 字节码（.class），再用 JVM 解释执行。

> [其他区别]
>
> C++对所有的数字类型有标准的范围限制，但字节长度是跟具体实现相关的，同一个类型在不同操作系统可能长度不一样。Java在所有平台上对所有的基本类型都有标准的范围限制和字节长度。
> C++除了一些比较少见的情况之外和C语言兼容 。 Java没有对任何之前的语言向前兼容。但在语法上受 C/C++ 的影响很大。
> C++允许直接调用本地的系统库 。 Java要通过JNI调用, 或者 JNA。
> C++允许过程式程序设计和面向对象程序设计 。Java必须使用面向对象的程序设计方式。
> C++支持指针，引用，传值调用 。Java只有值传递。
> C++需要显式的内存管理，但有第三方的框架可以提供垃圾搜集的支持。支持析构函数。 Java 是自动垃圾收集的。没有析构函数的概念。
> C++支持多重继承，包括虚拟继承 。Java只允许单继承，需要多继承的情况要使用接口。

[引导方向 -> JVM](#)

Java 有自动垃圾收集机制，C++ 本身没有，只能引入第三方框架支持。

[引导方向 -> 面向对象 -> 设计模式](#oop)

Java 必须使用面向对象的程序设计方式，而 C++ 允许使用面向过程的方式。

Java 只允许单继承，需要多继承的情况得使用接口，C++ 支持多重继承，包括虚拟继承。

[引导方向 -> 值传递](#)

C++ 支持指针（存地址，移位读数据）、引用、传值调用，但 Java 只有值传递。

#### <span id="oop">说说面向对象</span>

在说面向对象之前，必须先说一下什么是面向过程。

**面向过程**把问题分解成一个个步骤，从开始一直执行到结束。只要掌握基础语法、还有 顺序 选择 循环这三种代码结构，就可以实现一切，但是随着代码增加，代码的可读性、可维护性、可扩展性越来越差，最根本的问题就是人力成本的增加。

**面向对象**则是把问题抽象成属性和行为，并将二者封装成一个个对象，然后基于这些对象的能力来实现复杂的业务逻辑，每个对象都可以类比成现实生活中的人或物，TA 们都有特定的能力，搭配使用可以解决各种各样复杂的问题。

使用面向对象编程，能够提高代码的可读性、可维护性、可扩展性、可复用性，这就不得不提面向对象的三大基本特征了：`封装`、`继承`、`多态`。

- **封装：**就是定义一个类（Class），把实现特定逻辑的代码抽象成这个类的行为（Method），把其中的变量抽象成这个类的属性（Field）。比如我定义一个代表`交通工具`的类，它就需要有`运输`的功能，也就是行为，它还会有`速度`、`功率`、`功耗`等属性。
- **继承：**继承就是字面意思，一个类可以继承另一个类的属性和行为，然后复用另一个类的能力。
- **多态：**多态离不开继承，在继承的基础上，子类可以重写从父类继承过来的方法。编写代码时，使用父类声明，但执行调用时取决于实际传入的对象。

[引导方向 -> 设计模式](#)

面向对象还有一些基本设计原则<font title=green>SOLLIDC</font>：

- 单一职责原则

- 开闭原则（对扩展开放，对修改关闭）

- 里氏替换原则（可以扩展父类，但不要改变父类原有功能）

- 迪米特原则（最少知道原则）

- 接口隔离原则（细化接口）

- 依赖倒置原则（依赖抽象，不要依赖实现）

- 合成复用原则（组合/聚合，少用继承）

在这些基本的设计原则之上，还衍生出了很多设计模式，面向对象的思想可以用在类、方法、属性的设计，也可以用在模块、服务、系统架构的设计，能够帮助我们实现高内聚低耦合的系统，提高代码的可读性、可扩展性、可维护性、可复用性，而好的代码设计、架构设计是能够大大节省软件开发的人力成本的，这也是我们使用各种框架、各种中间件的意义。

#### 为什么 Java 不支持多继承？

多继承会引入菱形继承问题，就是当一个类同时继承了类A和类B，类A和类B有完全相同的方法，那么子类调用的时候到底要调类A的还是类B的，就会产生歧义，C++为了解决这个问题，引入了虚继承（又称共享继承），但即使是 C++ 也不推荐多继承，应该尽量避免；

为了避免这些麻烦，Java 就干脆不支持多继承，事实上多继承的使用场景真的很少；不过 Java 支持接口多继承，但方法的逻辑都是由子类自己实现的，所以不存在上面说的问题。

不过从 Java 8 开始，接口支持 default 方法，那当一个类实现了两个接口，且它们拥有相同的 default 方法，这时就要求子类必须重写该方法，以此来解决菱形问题。

#### 如何理解 Java 中的多态？

多态就是同一个操作（方法）作用于不同的对象，可以有不同的解释，产生不同的执行结果。

多态是一种运行期状态，又称动态绑定：**根据运行期的实际类型来定位方法执行的版本**。

多态的实现一般有 3 个步骤：

1. 继承或接口实现
2. 子类要重写父类的方法
3. 父类的引用指向子类的对象

#### 接口和抽象类的区别，如何选择？

接口用来制定规范，抽象类用来继承和复用：

- 接口中的方法默认都是 public 且不能有实现体的，除了 java8 引入的 default 方法，接口中的属性默认都是 public static final 的；
- 抽象类一般会有至少一个 abstract 修饰的方法和一系列已实现的方法，抽象方法由子类来实现，并且子类会复用抽象类提供的非抽象方法，常用于模板模式。

#### Java中有了基本类型为什么还需要包装类？

Java 是一种面向对象的语言，为了赋予基本类型对象的特性，所以需要包装类。

基本类型在某些场景无法适用，比如集合的泛型必须是 Object，没有包装类就不行。

![基本类型和包装类](../images/基本类型和包装类.png)

#### 为什么不能用浮点数表示金额？

二进制无法表示所有的小数，float（单精度浮点数） 和 double（双精度浮点数） 能表示的小数都是一个近似值，用他们进行高精度运算时，会发生精度丢失；

所以不能用浮点数表示金额，否则会发生资损，Java 提供了 `BigDecimal` 来进行精确的运算。

#### 为什么不能用 BigDecimal 的 equals 方法做等值比较？

因为 `BigDecimal` 的 equals 除了比较数值，还会比较 `scale 标度`，比如：`3.14` 和 `3.140` 的 `scale` 分别为 2 和 3，用 equals 比较它们是否相等会返回 `false`。

`BigDecimal` 比较两个值是否相等应该使用 `compareTo`：

```java
public statci void main(String[] args) {
    BigDecimal a = new BigDecimal("3.14");
    BigDecimal b = new BigDecimal("3.140");
    System.out.println(a.equals(b)); // result: false
    System.out.println(a.compareTo(b)); // result: 0
}
```

#### 为什么不能使用 new BigDecimal(double) 构建 BigDecimal 对象？

有精度损失的风险，实际存储的是一个小数位数很长的值，一般都是使用 `new BigDecimal(String)` 来构建 BigDecimal 对象。

或者使用 `BigDecimal.valueOf(double)` ，它内部使用 `Double.toString` 对尾数进行了截断。

#### 为什么对 Java 中的负数取绝对值结果不一定是正数？

这是一个越界问题，Integer 能表示的最小值为 `-2^31`，最大值为 `2^31 - 1`，当对最小值取绝对值时，就会发现还是它本身。

![int最大值和最小值](../images/int最大值和最小值.png)

#### String、StringBuilder 和 StringBuffer 的区别？

String 是不可变的，StringBuilder 和 StringBuffer 都是可变的；

StringBuffer 是线程安全的，StringBuilder 都是非线程安全的；

[引导方向 -> 线程安全](#)

不过 StringBuffer 中的方法通过 `synchronized` 实现线程安全，性能较差，一般不会使用。

#### String 的 "+" 是如何实现的？

通过反编译可以发现，字符串拼接是 new 了一个 `StringBuilder`，使用它的 `append` 方法来实现的。

#### String 是怎么实现的？

jdk8 及之前的版本都是使用 `char[]` 实现，但 jdk9 开始就改用 `byte[]` 实现了。

java 内部是使用 UTF-16 来编码的，每一个字符占据 2 个字节；但是一些简单得字符，如：ISO8859-1(Latin1) 当中的字符单字节就能表示了，但是在字符串当中还是得用 char，也就是两个字节来表示，这就有点浪费了，于是从 jdk9 开始就废弃了 `char[]` 改用了 `byte[]`，并加入了一个编码标识符：

```java
private final byte coder;
```

- coder 等于 0，表示  LATIN1 编码，即 1 个字节代表 1 个字符；

- coder 等于 1，表示 UTF-16 编码，即 2 个字节代表 1 个字符。

#### 在 for 循环中使用 "+" 进行字符串拼接有什么问题？

在 for 循环中使用 "+" 进行字符串拼接每次都会 new 一个 StringBuilder 再调用 append：

```java
str = (new StringBuilder()).append(str).append(s).toString();
```

频繁创建对象会造成内存资源浪费，还增加程序运行时间。

#### String 为什么设计成不可变的？

String 被设计为不可变的主要是考虑了安全性、性能和线程安全的问题。

- 字符串经常用来存储敏感信息，如：用户名、密码、url 等，如果是可变的，字符串的内容将变得不可信，增加了安全隐患。

- 因为字符串是不可变的，所以是线程安全的，不需要额外编写线程安全的代码；如果字符串是可变的，那多线程访问的时候就需要考虑线程安全的问题了。
- 字符串是使用最频繁的数据结构，JVM 在 heap 中专门开辟了一块空间作为字符串常量池，用于缓存字符串对象，相同的字符串不会重复创建，而是复用字符串常量池中的，这可以避免频繁创建字符串，提升性能；如果字符串是可变的，就无法实现这个功能了，因为一旦字符串被修改，所有引用到的地方都会跟着变。

- 还有像 HashMap 会频繁地使用 `hashCode()` 方法，得益于 String 的不可变性，String 类在创建时会计算和缓存它的哈希码，之后使用无需再计算，也提高了性能。

